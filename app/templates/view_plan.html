{% extends "base.html" %}

{% block title %}Radio planas - {{ plan.campaign_name }}{% endblock %}

{% block content %}
<div class="container-fluid p-0">
    <!-- Header Section -->
    <div class="header-section mb-4">
        <div class="header-card">
            <div class="header-top">
                <div class="campaign-title">
                    <h1 style="color: white;">{{ plan.campaign_name }}</h1>
                    <span class="campaign-subtitle" style="color: rgba(255, 255, 255, 0.9);">Radijo kampanijos planavimas</span>
                </div>
                <div class="header-actions">
                    <button href="/api/plans/{{ plan.id }}/export" class="btn-professional btn-primary">
                        <i class="bi bi-download"></i>
                        <span>Eksportuoti</span>
                    </button>
                    <a href="/planning/new" class="btn-professional btn-secondary">
                        <i class="bi bi-arrow-left"></i>
                        <span>Atgal</span>
                    </a>
                </div>
            </div>

            <div class="info-grid">
                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-building info-icon"></i>
                        <span class="info-label">Agentūra</span>
                    </div>
                    <div class="info-value">BPN LT</div>
                </div>

                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-person-badge info-icon"></i>
                        <span class="info-label">Klientas</span>
                    </div>
                    <div class="info-value">{{ plan.client_brand_name }}</div>
                </div>

                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-megaphone info-icon"></i>
                        <span class="info-label">Kampanija</span>
                    </div>
                    <div class="info-value">{{ plan.campaign_name }}</div>
                </div>

                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-people info-icon"></i>
                        <span class="info-label">Tikslinė grupė</span>
                    </div>
                    <div class="info-value">{{ plan.target_audience }}</div>
                </div>

                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-calendar-range info-icon"></i>
                        <span class="info-label">Laikotarpis</span>
                    </div>
                    <div class="info-value">{{ plan.start_date }} - {{ plan.end_date }}</div>
                </div>

                <div class="info-item">
                    <div class="info-header">
                        <i class="bi bi-geo-alt info-icon"></i>
                        <span class="info-label">Šalis</span>
                    </div>
                    <div class="info-value">Lietuva</div>
                </div>
            </div>

            <div class="clips-section">
                <div class="info-item full-width">
                    <div class="info-header">
                        <i class="bi bi-film info-icon"></i>
                        <span class="info-label">Klipų informacija</span>
                    </div>
                    <div class="info-value">
                        {% set clips_list = plan.clips.all() %}
                        {% if clips_list %}
                            {% for clip in clips_list %}
                                {{ clip.name }} ({{ clip.duration }}s){% if not loop.last %}, {% endif %}
                            {% endfor %}
                        {% else %}
                            Nėra pridėtų klipų
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Calendar Section -->
    <div class="mb-4">
        <!-- Calendar Section -->
        <div class="professional-section">
            <div class="section-header">
                <div class="section-title">
                    <h3>Planavimo kalendorius</h3>
                    <span class="section-subtitle">{{ plan.start_date }} - {{ plan.end_date }}</span>
                </div>
            </div>

            <div class="table-container">
                <div class="table-responsive">
                    <table class="professional-table" id="calendar-table">
                        <thead>
                            <tr id="calendar-header">
                                <th class="station-column">Radijo stotis</th>
                                <!-- Date headers will be generated here -->
                            </tr>
                        </thead>
                        <tbody id="calendar-body">
                            <!-- Station rows with input cells will be generated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Discount Controls -->
    <div class="professional-section mb-4">
        <div class="section-header">
            <div class="section-title">
                <h3>Nuolaidų valdymas</h3>
                <span class="section-subtitle">Pritaikykite nuolaidas visam planui</span>
            </div>
        </div>

        <div class="controls-grid">
            <div class="control-item">
                <label class="control-label">Mūsų nuolaida (%)</label>
                <div class="input-group-professional">
                    <input type="number"
                           class="form-control-professional"
                           id="globalOurDiscount"
                           value="{{ plan.our_discount }}"
                           min="0"
                           max="100"
                           step="1">
                    <span class="input-suffix">%</span>
                </div>
            </div>

            <div class="control-item">
                <label class="control-label">Kliento nuolaida (%)</label>
                <div class="input-group-professional">
                    <input type="number"
                           class="form-control-professional"
                           id="globalClientDiscount"
                           value="{{ plan.client_discount }}"
                           min="0"
                           max="100"
                           step="1">
                    <span class="input-suffix">%</span>
                </div>
            </div>

            <div class="control-item">
                <button class="btn-professional btn-primary btn-full" onclick="applyDiscountsToAll()">
                    <i class="bi bi-check-circle"></i>
                    <span>Pritaikyti visoms eilutėms</span>
                </button>
            </div>

            <div class="control-item">
                <small class="help-text">
                    Įrašykite nuolaidas ir paspauskite "Pritaikyti" kad atnaujinti visą lentelę
                </small>
            </div>
        </div>
    </div>

    <!-- Excel-style Planning Tables - Each Station Separate -->
    {% for station in stations %}
    <div class="professional-section station-section" data-station-id="{{ station.id }}">
        <div class="section-header">
            <div class="section-title">
                <h3>
                    <i class="bi bi-broadcast"></i>
                    {{ station.name }}
                </h3>
                <span class="section-subtitle">Kampanijos spotų paskirstymas ir finansinė analizė</span>
            </div>
        </div>

        <div class="planning-table-container">
            <div class="table-responsive station-table-wrapper" data-station-id="{{ station.id }}">
                <table class="planning-table">
                    <thead>
                        <tr class="main-header">
                            <th rowspan="2" class="station-header">Kanalas</th>
                            <th rowspan="2" class="time-header">Laikas</th>
                            <th rowspan="2" class="weekday-header">Savaitės<br>diena</th>
                            <th rowspan="2" class="spec-header">Spec.<br>pozicija</th>
                            <th rowspan="2" class="count-header">Klipų<br>skaičius</th>
                            <th rowspan="2" class="duration-header">Klipo<br>trukmė</th>
                            <th colspan="5" class="rating-group-header">Reitingai ir efektyvumas</th>
                            <th colspan="5" class="pricing-group-header">Kainodara</th>
                            <th colspan="4" class="totals-group-header">Viso sumos</th>
                            <th colspan="2" class="discount-group-header">Nuolaidos</th>
                            <!-- Calendar date headers will be added here -->
                        </tr>
                        <tr class="sub-header">
                            <!-- Rating columns -->
                            <th class="grp-header">GRP</th>
                            <th class="trp-header">TRP</th>
                            <th class="affinity-header">Affinity</th>
                            <!-- Pricing columns -->
                            <th class="trp-price-header">1 sec TRP<br>kaina</th>
                            <th class="base-price-header">Įkainis</th>
                            <th class="seasonal-header">Spec. Indeksas</th>
                            <th class="price-with-index-header">Sez. Indeksas</th>
                            <!-- Totals columns -->
                            <th class="final-price-header">GROSS<br>kaina</th>
                            <th class="total-before-header">Kaina po mūsų<br>nuolaidos</th>
                            <th class="total-after-header">Kaina po kliento<br>nuolaidos</th>
                            <th class="our-discount-header">Mūsų nuolaida %</th>
                            <th class="client-discount-header">Kliento nuolaida %</th>
                            <!-- Date headers -->
                            {% for date in calendar_data.dates %}
                                <th class="calendar-date-header {% if date.weekday() >= 5 %}weekend-date{% endif %}">
                                    <div class="date-info">
                                        <span class="date-day">{{ date.strftime('%d') }}</span>
                                        <span class="date-month">{{ date.strftime('%m') }}</span>
                                    </div>
                                </th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody class="station-tbody">
                        <!-- All weekday rows first -->
                        {% for time_slot in time_slots %}
                            <tr class="planning-row station-{{ station.id }}-row" data-station-id="{{ station.id }}" data-time-slot="{{ time_slot }}" data-is-weekend="false">
                                <td>{{ station.name }}</td>
                                <td>{{ time_slot }}</td>
                                <td>I-V</td>
                                <td>0</td>
                                <td class="spot-count">
                                    <div class="spot-count-controls">
                                        <button class="btn-spot-control btn-minus" data-action="minus" title="Sumažinti">-</button>
                                        <span class="spot-number">0</span>
                                        <button class="btn-spot-control btn-plus" data-action="plus" title="Padidinti">+</button>
                                    </div>
                                </td>
                                <td class="clip-duration">{% set clips_list = plan.clips.all() %}{% if clips_list and clips_list|length > 0 %}{{ clips_list[0].duration }}{% else %}30{% endif %}</td>
                                <td class="grp">0</td>
                                <td class="trp">0</td>
                                <td class="affinity">0</td>
                                <td class="trp-price">0</td>
                                <td class="base-price">0</td>
                                <td class="seasonal-index">{{ seasonal_indices.get(station.id, 1) }}</td>
                                <td class="price-with-index">0</td>
                                <td class="final-price">0</td>
                                <td class="total-before-discount">0</td>
                                <td class="total-after-discount">0</td>
                                <td class="our-discount-percent">{{ plan.our_discount }}%</td>
                                <td class="client-discount-percent">{{ plan.client_discount }}%</td>
                                <!-- Calendar cells for each date - only weekdays clickable -->
                                {% for date in calendar_data.dates %}
                                    {% set is_weekend = date.weekday() >= 5 %}
                                    <td class="calendar-cell {% if is_weekend %}weekend-cell{% endif %}"
                                        data-date="{{ date.isoformat() }}"
                                        {% if not is_weekend %}onclick="toggleSpot(this)"{% endif %}>
                                        <span class="spot-indicator"></span>
                                    </td>
                                {% endfor %}
                            </tr>
                        {% endfor %}

                        <!-- All weekend rows after -->
                        {% for time_slot in time_slots %}
                            <tr class="planning-row station-{{ station.id }}-row weekend-row" data-station-id="{{ station.id }}" data-time-slot="{{ time_slot }}" data-is-weekend="true">
                                <td>{{ station.name }}</td>
                                <td>{{ time_slot }}</td>
                                <td>VI-VII</td>
                                <td>0</td>
                                <td class="spot-count">
                                    <div class="spot-count-controls">
                                        <button class="btn-spot-control btn-minus" data-action="minus" title="Sumažinti">-</button>
                                        <span class="spot-number">0</span>
                                        <button class="btn-spot-control btn-plus" data-action="plus" title="Padidinti">+</button>
                                    </div>
                                </td>
                                <td class="clip-duration">{% set clips_list = plan.clips.all() %}{% if clips_list and clips_list|length > 0 %}{{ clips_list[0].duration }}{% else %}30{% endif %}</td>
                                <td class="grp">0</td>
                                <td class="trp">0</td>
                                <td class="affinity">0</td>
                                <td class="trp-price">0</td>
                                <td class="base-price">0</td>
                                <td class="seasonal-index">{{ seasonal_indices.get(station.id, 1) }}</td>
                                <td class="price-with-index">0</td>
                                <td class="final-price">0</td>
                                <td class="total-before-discount">0</td>
                                <td class="total-after-discount">0</td>
                                <td class="our-discount-percent">{{ plan.our_discount }}%</td>
                                <td class="client-discount-percent">{{ plan.client_discount }}%</td>
                                <!-- Calendar cells for each date - only weekends clickable -->
                                {% for date in calendar_data.dates %}
                                    {% set is_weekend = date.weekday() >= 5 %}
                                    <td class="calendar-cell {% if is_weekend %}weekend-cell{% endif %}"
                                        data-date="{{ date.isoformat() }}"
                                        {% if is_weekend %}onclick="toggleSpot(this)"{% endif %}>
                                        <span class="spot-indicator"></span>
                                    </td>
                                {% endfor %}
                            </tr>
                        {% endfor %}

                        <!-- Station totals row -->
                        <tr class="station-totals" data-station-id="{{ station.id }}" style="background-color: #fff3cd; font-weight: bold;">
                            <td colspan="2" style="text-align: right; padding-right: 10px;">VISO:</td>
                            <td></td>
                            <td></td>
                            <td class="station-total-spots" id="station-{{ station.id }}-total-spots">0</td>
                            <td></td>
                            <td class="station-total-grp" id="station-{{ station.id }}-total-grp">0</td>
                            <td class="station-total-trp" id="station-{{ station.id }}-total-trp">0</td>
                            <td class="station-total-affinity" id="station-{{ station.id }}-total-affinity">0</td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td class="station-total-before-discount" id="station-{{ station.id }}-total-before-discount">0</td>
                            <td class="station-total-after-discount" id="station-{{ station.id }}-total-after-discount">0</td>
                            <td></td>
                            <td></td>
                            <!-- Empty calendar cells for totals row -->
                            {% for date in calendar_data.dates %}
                                <td></td>
                            {% endfor %}
                        </tr>

                    </tbody>
                </table>
            </div>
        </div>
    </div>
    {% endfor %}
</div>

{% endblock %}

{% block extra_css %}
<style>
/* Ensure GRP/TRP cells can display decimal values properly */
.grp, .trp, .affinity {
    min-width: 70px;
    white-space: nowrap;
    text-align: center;
    font-family: monospace;
}

/* Ensure station totals cells also display properly */
.station-total-grp, .station-total-trp, .station-total-affinity {
    min-width: 70px;
    white-space: nowrap;
    text-align: center;
    font-family: monospace;
}

/* Improve overall table cell spacing */
.radio-planning-table td {
    padding: 4px 6px;
    font-size: 13px;
}

/* Make numeric cells consistent */
.spot-count, .price-cell, .base-price, .final-price, .total-before-discount, .total-after-discount {
    text-align: center;
    font-family: monospace;
    min-width: 50px;
}

/* Weekend row styling - keep minimal styling */
.weekend-row {
    /* Same background as regular rows */
}

.weekend-row td {
    /* Same styling as regular rows */
}

/* Weekend calendar cells */
.weekend-cell {
    background-color: #e3f2fd !important;
    cursor: pointer;
}

/* Disabled weekend cells in weekday rows */
tr:not(.weekend-row) .weekend-cell {
    background-color: #f5f5f5 !important;
    cursor: not-allowed;
    opacity: 0.5;
}

/* Disabled weekday cells in weekend rows */
.weekend-row .calendar-cell:not(.weekend-cell) {
    background-color: #f5f5f5 !important;
    cursor: not-allowed;
    opacity: 0.5;
}

/* Spot count controls */
.spot-count-controls {
    display: flex;
    align-items: center;
    gap: 4px;
    justify-content: center;
}

.btn-spot-control {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    border: 1px solid #ddd;
    background: white;
    color: #333;
    border-radius: 4px;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}

.btn-spot-control:hover {
    background: #f0f0f0;
    border-color: #007bff;
    color: #007bff;
}

.btn-spot-control:active {
    background: #007bff;
    color: white;
    transform: scale(0.95);
}

.btn-spot-control:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Plus button - Green */
.btn-plus {
    background: #28a745;
    border-color: #28a745;
    color: white;
}
.btn-plus:hover {
    background: #218838;
    border-color: #1e7e34;
    color: white;
}
.btn-plus:active {
    background: #1e7e34;
    color: white;
    transform: scale(0.95);
}

/* Minus button - Red */
.btn-minus {
    background: #dc3545;
    border-color: #dc3545;
    color: white;
}
.btn-minus:hover {
    background: #c82333;
    border-color: #bd2130;
    color: white;
}
.btn-minus:active {
    background: #bd2130;
    color: white;
    transform: scale(0.95);
}

.btn-minus:hover {
    background: #f8d7da;
    border-color: #dc3545;
    color: #dc3545;
}

.btn-plus:hover {
    background: #d4edda;
    border-color: #28a745;
    color: #28a745;
}

.spot-number {
    min-width: 20px;
    text-align: center;
    font-weight: bold;
    font-size: 14px;
}
</style>
{% endblock %}

{% block extra_js %}
<script>
// Load data on page load - Multiple approaches for reliability
function initializePage() {
    console.log('=== INITIALIZING PAGE ===');

    try {
        // Only generate calendar grid if the calendar body is empty (no server-generated content)
        const calendarBody = document.getElementById('calendar-body');
        if (calendarBody && calendarBody.children.length === 0) {
            console.log('Calendar body is empty, generating calendar grid');
            generateCalendarGrid();
        } else {
            console.log('Calendar body has content, skipping generateCalendarGrid()');
        }

        console.log('Now calling loadExistingSpots()');
        loadExistingSpots();

        // After loading existing spots, load captured station data
        setTimeout(() => {
            loadCapturedStationData();
            loadSeasonalIndices(); // Load seasonal indices for current month

            // Load spot counts AFTER all other initialization is complete
            setTimeout(() => {
                loadSpotCounts();

                // Update station totals AFTER everything is loaded
                setTimeout(() => {
                    console.log('=== CALLING updateAllStationTotals after page load ===');
                    updateAllStationTotals();

                    // Start the persistent spot count loader
                    startPersistentSpotLoader();
                }, 500);
            }, 200);
        }, 1000); // Increased timeout

        initializeDragToScroll();
    } catch (error) {
        console.error('Error in initializePage:', error);
    }
}

// Try multiple event listeners for maximum reliability
document.addEventListener('DOMContentLoaded', initializePage);
window.addEventListener('load', function() {
    console.log('Window load event - calling loadExistingSpots again');
    setTimeout(loadExistingSpots, 100);
});

// Also try immediate execution if document is already ready
if (document.readyState === 'loading') {
    console.log('Document still loading, waiting for DOMContentLoaded');
} else {
    console.log('Document already loaded, calling initializePage immediately');
    setTimeout(initializePage, 100);
}

// SPOT COUNT LOADER - Load spots once on page load
function loadSpotCounts() {
    console.log('=== LOADING SPOT COUNTS ON PAGE LOAD ===');

    const spotNumbers = document.querySelectorAll('.spot-number');
    console.log(`Found ${spotNumbers.length} spot number elements`);

    // Load spots from API
    fetch('/api/plans/{{ plan.id }}')
        .then(response => response.json())
        .then(data => {
            console.log('Page load - API returned:', data.spots);

            if (data.spots && data.spots.length > 0) {
                console.log('Found spots in API, updating display...');

                data.spots.forEach(spot => {
                    // Determine if this spot is for a weekend based on the date
                    const spotDate = new Date(spot.date);
                    const dayOfWeek = spotDate.getDay();
                    // JavaScript: Sunday = 0, Monday = 1, ..., Saturday = 6
                    // Python weekday(): Monday = 0, Tuesday = 1, ..., Sunday = 6
                    // Python uses >= 5 for weekend (Saturday=5, Sunday=6)
                    // So we need to match Python's logic: convert JS day to Python weekday
                    const pythonWeekday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convert JS to Python weekday
                    const isWeekend = pythonWeekday >= 5; // Match Python's weekend calculation

                    console.log(`Spot date: ${spot.date}, dayOfWeek: ${dayOfWeek}, pythonWeekday: ${pythonWeekday}, isWeekend: ${isWeekend}`);

                    // Find the SPECIFIC row for this station/time slot/weekend status
                    const rows = document.querySelectorAll(`tr[data-station-id="${spot.station_id}"][data-time-slot="${spot.time_slot}"][data-is-weekend="${isWeekend}"]`);
                    console.log(`Found ${rows.length} rows for station ${spot.station_id}, time ${spot.time_slot}, weekend=${isWeekend}`);

                    rows.forEach(row => {
                        const spotNumberElement = row.querySelector('.spot-number');
                        if (spotNumberElement) {
                            console.log(`Updating spot count from ${spotNumberElement.textContent} to ${spot.spot_count}`);
                            spotNumberElement.textContent = spot.spot_count;

                            // Recalculate TRP price and other calculations for this row
                            console.log(`Calling calculateRowPrices for station ${spot.station_id}, time ${spot.time_slot}`);
                            calculateRowPrices(row);
                        }
                    });
                });

                console.log('Spot counts loaded successfully!');

                // Load prices for all stations first, then calculate TRP prices
                console.log('Loading prices for all stations and calculating TRP...');
                setTimeout(() => {
                    // Trigger price loading for all stations
                    console.log('Triggering price loading for all stations...');
                    if (typeof loadStationPrices === 'function') {
                        loadStationPrices();
                    }

                    // Wait a bit for prices to load, then calculate TRP
                    setTimeout(() => {
                        console.log('Calculating TRP prices for all rows...');
                        const allRows = document.querySelectorAll('tr[data-station-id][data-time-slot]');
                        allRows.forEach(row => {
                            const stationId = row.getAttribute('data-station-id');
                            const timeSlot = row.getAttribute('data-time-slot');
                            const basePrice = parseFloat(row.querySelector('.base-price')?.textContent || 0);
                            const trp = parseFloat(row.querySelector('.trp')?.textContent || 0);

                            console.log(`Station ${stationId}, time ${timeSlot}: basePrice=${basePrice}, trp=${trp}`);

                            if (basePrice > 0 && trp > 0) {
                                const trpPrice = basePrice / trp;
                                row.querySelector('.trp-price').textContent = trpPrice.toFixed(2);
                                console.log(`✓ TRP price calculated: ${trpPrice.toFixed(2)}`);
                            } else {
                                console.log(`✗ Skipping (missing data): basePrice=${basePrice}, trp=${trp}`);
                            }
                        });
                    }, 1000); // Wait 1 second for prices to load
                }, 100);
            } else {
                console.log('No spots found in API response');
            }
        })
        .catch(error => {
            console.error('Spot count loading error:', error);
        });
}

// loadSpotCounts is now called from initializePage after other initialization

function generateCalendarGrid() {
    const startDate = new Date('{{ plan.start_date }}');
    const endDate = new Date('{{ plan.end_date }}');
    const calendarHeader = document.getElementById('calendar-header');
    const calendarBody = document.getElementById('calendar-body');

    if (!calendarHeader || !calendarBody) return;

    // Generate header with dates
    let headerHtml = '<th style="min-width: 150px;">Radijo stotis</th>';
    let currentDate = new Date(startDate);
    const dates = [];

    while (currentDate <= endDate) {
        const dayName = currentDate.toLocaleDateString('lt-LT', { weekday: 'short' });
        const dateStr = currentDate.toLocaleDateString('lt-LT', { day: '2-digit', month: '2-digit' });
        const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
        const dateIso = currentDate.toISOString().split('T')[0];

        dates.push({
            iso: dateIso,
            dayName: dayName,
            dateStr: dateStr,
            isWeekend: isWeekend
        });

        headerHtml += `
            <th class="text-center ${isWeekend ? 'weekend-header' : ''}" style="min-width: 80px;">
                <div class="fw-bold">${dayName}</div>
                <div class="small">${dateStr}</div>
            </th>
        `;

        currentDate.setDate(currentDate.getDate() + 1);
    }

    calendarHeader.innerHTML = headerHtml;

    // Generate body with station rows
    const stations = [
        {% for station in stations %}
        { id: {{ station.id }}, name: '{{ station.name }}' }{% if not loop.last %},{% endif %}
        {% endfor %}
    ];

    let bodyHtml = '';
    stations.forEach(station => {
        bodyHtml += `<tr data-station-id="${station.id}">`;
        bodyHtml += `<td class="station-name-cell"><strong>${station.name}</strong></td>`;

        dates.forEach(date => {
            bodyHtml += `
                <td class="calendar-input-cell ${date.isWeekend ? 'weekend-cell' : ''}" data-date="${date.iso}" data-station-id="${station.id}">
                    <input type="number"
                           class="form-control form-control-sm text-center"
                           min="0"
                           max="99"
                           value="0"
                           style="width: 60px; font-size: 11px;"
                           onchange="updateSpotCount(this)">
                </td>
            `;
        });

        bodyHtml += '</tr>';
    });

    calendarBody.innerHTML = bodyHtml;
}

// Load seasonal indices for all stations based on current month
function loadSeasonalIndices() {
    console.log('=== LOADING SEASONAL INDICES ===');

    // Get current month (1-12)
    const currentDate = new Date();
    const currentMonth = currentDate.getMonth() + 1; // JavaScript months are 0-based, so add 1

    console.log(`Current month: ${currentMonth}`);

    // Get all unique station IDs and their groups
    const stationElements = document.querySelectorAll('[data-station-id]');
    const stationIds = new Set();

    stationElements.forEach(element => {
        const stationId = element.dataset.stationId;
        if (stationId) {
            stationIds.add(stationId);
        }
    });

    console.log(`Found ${stationIds.size} unique stations:`, Array.from(stationIds));

    // Load seasonal indices for each station
    stationIds.forEach(stationId => {
        console.log(`Loading seasonal index for station ${stationId}`);

        fetch(`/api/seasonal-indices/station/${stationId}/month/${currentMonth}`)
            .then(response => response.json())
            .then(data => {
                console.log(`Station ${stationId} seasonal index data:`, data);

                if (data.seasonal_index !== undefined) {
                    // Update all rows for this station with the seasonal index
                    const stationRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);

                    stationRows.forEach(row => {
                        const seasonalCell = row.querySelector('.seasonal-index');
                        if (seasonalCell) {
                            const oldValue = seasonalCell.textContent;
                            seasonalCell.textContent = data.seasonal_index;
                            console.log(`Updated station ${stationId} seasonal index from ${oldValue} to ${data.seasonal_index}`);

                            // Recalculate prices for this row
                            calculateRowPrices(row);
                        }
                    });
                } else {
                    console.log(`No seasonal index found for station ${stationId}, keeping default value`);
                }
            })
            .catch(error => {
                console.error(`Error loading seasonal index for station ${stationId}:`, error);
            });
    });
}

function loadCapturedStationData() {
    // Load captured station data for this plan
    console.log('Loading captured station data for plan {{ plan.id }}');

    fetch(`/api/plans/{{ plan.id }}/captured-data`)
        .then(response => response.json())
        .then(capturedData => {
            console.log(`Loaded ${capturedData.length} captured station data records`);

            capturedData.forEach(data => {
                // Find the corresponding row in the planning table
                const row = document.querySelector(`tr[data-station-id="${data.station_id}"][data-time-slot="${data.time_slot}"][data-is-weekend="${data.is_weekend}"]`);

                if (row) {
                    // Populate with captured values from plan creation time
                    const grpCell = row.querySelector('.grp');
                    const trpCell = row.querySelector('.trp');
                    const affinityCell = row.querySelector('.affinity');
                    const basePriceCell = row.querySelector('.base-price');
                    const seasonalIndexCell = row.querySelector('.seasonal-index');

                    if (grpCell) grpCell.textContent = data.grp.toFixed(2);
                    if (trpCell) trpCell.textContent = data.trp.toFixed(2);
                    if (affinityCell) affinityCell.textContent = data.affinity.toFixed(2);
                    if (basePriceCell) basePriceCell.textContent = data.base_price.toFixed(2);
                    if (seasonalIndexCell) seasonalIndexCell.textContent = data.seasonal_index.toFixed(2);

                    console.log(`Applied captured data: Station ${data.station_name}, slot ${data.time_slot}, GRP=${data.grp}, TRP=${data.trp}`);
                }
            });
        })
        .catch(error => {
            console.error('Error loading captured station data:', error);
        });
}

function applyCurrentRatingsForPreview(stationId, ratings) {
    // Apply current ratings only to empty cells (for preview)
    const stationRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);

    stationRows.forEach(row => {
        const timeSlot = row.dataset.timeSlot;
        const isWeekend = row.dataset.isWeekend === 'true';
        if (!timeSlot) return;

        const grpCell = row.querySelector('.grp');
        const trpCell = row.querySelector('.trp');
        const affinityCell = row.querySelector('.affinity');

        // Only update if the cell is currently empty/zero
        if (grpCell && (grpCell.textContent.trim() === '0' || grpCell.textContent.trim() === '')) {
            const rating = ratings.find(r => r.time_slot === timeSlot && r.is_weekend === isWeekend);
            if (rating) {
                grpCell.textContent = rating.grp.toFixed(2);
                if (trpCell) trpCell.textContent = rating.trp.toFixed(2);
                if (affinityCell) affinityCell.textContent = rating.affinity.toFixed(2);
                console.log(`Loaded preview ratings for station ${stationId}, slot ${timeSlot}: GRP=${rating.grp}, TRP=${rating.trp}`);
            }
        }
    });
}

function loadStationRatings() {
    // DISABLED: This function is no longer used
    // Use loadCurrentRatingsForPreview() for new plans or loadExistingSpots() for existing plans
    console.log('loadStationRatings() is disabled - use loadCurrentRatingsForPreview() or loadExistingSpots()');
}

function loadSavedSpotRatings() {
    // Load saved ratings from RadioSpot database records for this plan
    fetch(`/api/plans/{{ plan.id }}`)
        .then(response => response.json())
        .then(planData => {
            if (planData.spots && planData.spots.length > 0) {
                console.log(`Loading saved ratings from ${planData.spots.length} spots`);

                planData.spots.forEach(spot => {
                    // Find the corresponding row in the table
                    const row = document.querySelector(`tr[data-station-id="${spot.station_id}"][data-time-slot="${spot.time_slot}"]`);

                    if (row) {
                        // Populate with saved values from database
                        const grpCell = row.querySelector('.grp');
                        const trpCell = row.querySelector('.trp');
                        const affinityCell = row.querySelector('.affinity');

                        if (grpCell && spot.grp) {
                            grpCell.textContent = (spot.grp / spot.spot_count).toFixed(2); // Base GRP (divide by spot count)
                        }
                        if (trpCell && spot.trp) {
                            trpCell.textContent = (spot.trp / spot.spot_count).toFixed(2); // Base TRP (divide by spot count)
                        }
                        if (affinityCell && spot.affinity) {
                            affinityCell.textContent = spot.affinity.toFixed(2);
                        }

                        console.log(`Loaded saved ratings for station ${spot.station_id}, slot ${spot.time_slot}: GRP=${spot.grp}, TRP=${spot.trp}`);
                    }
                });

                // Update all totals after loading values
            } else {
                console.log('No spots found in plan - will only show values when spots are added');
            }
        })
        .catch(error => {
            console.error('Error loading saved spot ratings:', error);
            console.log('Will only show values when spots are added');
        });
}

function loadCurrentStationRatings() {
    // For new plans, load current station ratings
    const stationRows = document.querySelectorAll('.planning-row');
    const stationIds = new Set();

    stationRows.forEach(row => {
        const stationId = row.dataset.stationId;
        if (stationId) {
            stationIds.add(stationId);
        }
    });

    stationIds.forEach(stationId => {
        fetch(`/api/radio-stations/${stationId}/ratings?target_audience={{ plan.target_audience }}`)
            .then(response => response.json())
            .then(ratings => {
                applyCurrentStationRatings(stationId, ratings);
            })
            .catch(error => {
                console.error(`Error loading current ratings for station ${stationId}:`, error);
            });
    });
}

function applyCurrentStationRatings(stationId, ratings) {
    // Apply current ratings to new plans only
    const stationRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);

    stationRows.forEach(row => {
        const timeSlot = row.dataset.timeSlot;
        const isWeekend = row.dataset.isWeekend === 'true';
        if (!timeSlot) return;

        const grpCell = row.querySelector('.grp');
        const trpCell = row.querySelector('.trp');
        const affinityCell = row.querySelector('.affinity');

        if (grpCell && grpCell.textContent.trim() === '0') {
            const rating = ratings.find(r => r.time_slot === timeSlot && r.is_weekend === isWeekend);
            if (rating) {
                grpCell.textContent = rating.grp.toFixed(2);
                if (trpCell) trpCell.textContent = rating.trp.toFixed(2);
                if (affinityCell) affinityCell.textContent = rating.affinity.toFixed(2);
                console.log(`Loaded current ratings for station ${stationId}, slot ${timeSlot}: GRP=${rating.grp}, TRP=${rating.trp}`);
            }
        }
    });
}

function loadStationPrices() {
    // Get all unique station IDs from the table
    const stationRows = document.querySelectorAll('.planning-row');
    const stationIds = new Set();

    stationRows.forEach(row => {
        const stationId = row.dataset.stationId;
        if (stationId) {
            stationIds.add(stationId);
        }
    });

    // REMOVED: No longer loading prices automatically - plans keep their saved values
    // Prices will only be populated when spots are added via the backend
    console.log('Price loading disabled - only saved RadioSpot values will be used');
}

function applyStationPricesOnLoad(stationId, prices) {
    // Load prices only for empty cells (0 values), never overwrite existing values
    const stationRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);

    stationRows.forEach(row => {
        const timeSlot = row.dataset.timeSlot;
        const isWeekend = row.dataset.isWeekend === 'true';
        if (!timeSlot) return;

        // Only update if the base price cell is empty or 0 (initial load or new plans)
        const basePriceCell = row.querySelector('.base-price');
        if (basePriceCell && (basePriceCell.textContent.trim() === '0' || basePriceCell.textContent.trim() === '')) {
            const clipDuration = parseInt(row.querySelector('.clip-duration').textContent || 30);

            // Use new API endpoint to get exact price for this duration
            fetch(`/api/radio-stations/${stationId}/price?time_slot=${encodeURIComponent(timeSlot)}&duration=${clipDuration}&is_weekend=${isWeekend}`)
                .then(response => response.json())
                .then(priceData => {
                    if (priceData.price) {
                        basePriceCell.textContent = priceData.price.toFixed(2);
                        calculateRowPrices(row);
                        console.log(`Loaded price for station ${stationId}, slot ${timeSlot}: ${priceData.price}`);
                    }
                })
                .catch(error => {
                    console.error(`Error loading price for station ${stationId}, time ${timeSlot}, duration ${clipDuration}:`, error);
                });
        } else {
            console.log(`Skipping station ${stationId}, slot ${timeSlot} - already has price: ${basePriceCell ? basePriceCell.textContent : 'N/A'}`);
        }
    });
}

function calculateRowPrices(row) {
    // Get discount values from inputs (dynamic)
    const ourDiscount = parseFloat(document.getElementById('globalOurDiscount')?.value || {{ plan.our_discount }});
    const clientDiscount = parseFloat(document.getElementById('globalClientDiscount')?.value || {{ plan.client_discount }});

    // Get values from the row
    const basePrice = parseFloat(row.querySelector('.base-price').textContent || 0);
    const seasonalIndex = parseFloat(row.querySelector('.seasonal-index').textContent || 1.0);
    const spotCount = parseInt(row.querySelector('.spot-number').textContent || 0);

    // Calculate price with seasonal index
    const priceWithIndex = basePrice * seasonalIndex;
    row.querySelector('.price-with-index').textContent = priceWithIndex.toFixed(2);

    // Calculate clip price (single spot price after seasonal adjustment)

    // Calculate total before discount (price * spot count)
    const totalBeforeDiscount = priceWithIndex * spotCount;
    row.querySelector('.total-before-discount').textContent = totalBeforeDiscount.toFixed(2);

    // Apply discounts
    const priceAfterOurDiscount = totalBeforeDiscount * (1 - ourDiscount / 100);
    const finalPrice = priceAfterOurDiscount * (1 - clientDiscount / 100);
    row.querySelector('.final-price').textContent = priceWithIndex.toFixed(2); // Single spot final price
    row.querySelector('.total-after-discount').textContent = finalPrice.toFixed(2);

    // Calculate TRP price if TRP is available using formula: įkainis / TRP
    const trp = parseFloat(row.querySelector('.trp').textContent || 0);
    console.log(`TRP calculation - basePrice: ${basePrice}, trp: ${trp}, station: ${row.getAttribute('data-station-id')}, time: ${row.getAttribute('data-time-slot')}`);
    if (trp > 0) {
        const trpPrice = basePrice / trp;
        console.log(`TRP price calculated: ${trpPrice.toFixed(2)}`);
        row.querySelector('.trp-price').textContent = trpPrice.toFixed(2);
    } else {
        console.log('TRP is 0 or missing, skipping TRP price calculation');
    }
}

function toggleSpot(cell) {
    const row = cell.closest('tr');
    const stationId = row.dataset.stationId;
    const timeSlot = row.dataset.timeSlot;
    const isWeekend = row.dataset.isWeekend === 'true';
    const date = cell.dataset.date;

    // Toggle spot indicator
    const indicator = cell.querySelector('.spot-indicator');
    const currentCount = parseInt(indicator.textContent) || 0;
    const newCount = currentCount > 0 ? 0 : 1;

    indicator.textContent = newCount > 0 ? newCount : '';
    cell.classList.toggle('has-spot', newCount > 0);

    // Save or delete spot in backend with current station data
    if (newCount > 0) {
        saveSpotWithCurrentData(stationId, timeSlot, date, isWeekend, row);
    } else {
        deleteSpotFromBackend(stationId, timeSlot, date);
    }

    // Update totals
    updateRowTotals(row);
}

function calculateRowTotalsOnly(row) {
    const calendarCells = row.querySelectorAll('.calendar-cell');
    let totalSpots = 0;

    calendarCells.forEach(cell => {
        const count = parseInt(cell.querySelector('.spot-indicator').textContent) || 0;
        totalSpots += count;
    });

    row.querySelector('.spot-number').textContent = totalSpots;

    // Recalculate prices based on new spot count
    calculateRowPrices(row);
}

function updateRowTotals(row) {
    calculateRowTotalsOnly(row);

    // Update station totals after updating row totals
    const stationId = row.dataset.stationId;
    updateStationTotals(stationId);

    // Update calendar view
    updateCalendarSpotCounts();
}

function updateSpotCount(input) {
    const stationId = input.closest('td').dataset.stationId;
    const date = input.closest('td').dataset.date;
    const spotCount = parseInt(input.value) || 0;

    // Update the main planning table
    const planningRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);
    planningRows.forEach(row => {
        const cell = row.querySelector(`td[data-date="${date}"]`);
        if (cell) {
            const indicator = cell.querySelector('.spot-indicator');
            if (indicator) {
                indicator.textContent = spotCount > 0 ? spotCount : '';
                cell.classList.toggle('has-spot', spotCount > 0);
                updateRowTotals(row);
            }
        }
    });

    // Save to backend if needed
    if (spotCount > 0) {
        saveSpotToBackend(stationId, date, spotCount);
    }
}

function saveSpotWithCurrentData(stationId, timeSlot, date, isWeekend, row) {
    // Get current ratings from station (live data)
    fetch(`/api/radio-stations/${stationId}/ratings?target_audience={{ plan.target_audience }}`)
        .then(response => response.json())
        .then(ratings => {
            // Find rating for this time slot and weekend status
            const rating = ratings.find(r => r.time_slot === timeSlot && r.is_weekend === isWeekend);

            // Get current price from station (live data)
            const clipDuration = parseInt(row.querySelector('.clip-duration').textContent || 30);
            return fetch(`/api/radio-stations/${stationId}/price?time_slot=${encodeURIComponent(timeSlot)}&duration=${clipDuration}&is_weekend=${isWeekend}`)
                .then(priceResponse => priceResponse.json())
                .then(priceData => {
                    // Get current seasonal index
                    const seasonalIndex = parseFloat(row.querySelector('.seasonal-index').textContent || 1.0);

                    // Prepare spot data with current values
                    const spotData = {
                        station_id: parseInt(stationId),
                        date: date,
                        time_slot: timeSlot,
                        spot_count: 1,
                        clip_duration: clipDuration
                    };

                    // Save to backend - the backend will capture current values and store them
                    return fetch(`/api/plans/{{ plan.id }}/spots`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(spotData)
                    });
                });
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                console.error('Error saving spot:', data.error);
            } else {
                console.log('Spot saved with current station data captured');
                // Reload the spot data to show the captured values
                loadExistingSpots();
            }
        })
        .catch(error => {
            console.error('Error saving spot:', error);
        });
}

function deleteSpotFromBackend(stationId, timeSlot, date) {
    // TODO: Implement spot deletion API if needed
    console.log(`Deleting spot: station ${stationId}, slot ${timeSlot}, date ${date}`);
}

function updateCalendarSpotCounts() {
    // This function is now simpler since the calendar inputs directly control the values
    // We just need to sync existing spots from the planning table to calendar inputs
    const calendarInputs = document.querySelectorAll('.calendar-input-cell input');

    calendarInputs.forEach(input => {
        const stationId = input.closest('td').dataset.stationId;
        const date = input.closest('td').dataset.date;

        // Find corresponding spot count in planning table
        let totalSpots = 0;
        const planningRows = document.querySelectorAll(`tr[data-station-id="${stationId}"]`);
        planningRows.forEach(row => {
            const cell = row.querySelector(`td[data-date="${date}"]`);
            if (cell) {
                const spotCount = parseInt(cell.querySelector('.spot-indicator')?.textContent) || 0;
                totalSpots += spotCount;
            }
        });

        input.value = totalSpots;
    });
}

function updateStationTotals(stationId) {
    console.log(`=== updateStationTotals called for station ${stationId} ===`);

    // Use a small timeout to ensure all DOM updates have completed
    setTimeout(() => {
        const stationRows = document.querySelectorAll(`.station-${stationId}-row`);
        console.log(`Found ${stationRows.length} rows for station ${stationId}`);

        let totalSpots = 0;
        let totalGrp = 0;
        let totalTrp = 0;
        let totalAffinity = 0;
        let totalBeforeDiscount = 0;
        let totalAfterDiscount = 0;

        stationRows.forEach((row, index) => {
            // Debug: let's see what we can find in this row
            const spotNumberElement = row.querySelector('.spot-number');
            const grpElement = row.querySelector('.grp');
            const trpElement = row.querySelector('.trp');
            const affinityElement = row.querySelector('.affinity');
            const beforeDiscountElement = row.querySelector('.total-before-discount');
            const afterDiscountElement = row.querySelector('.total-after-discount');

            console.log(`Row ${index}:`, row);
            console.log(`Spot number element:`, spotNumberElement);
            console.log(`GRP element:`, grpElement);
            console.log(`TRP element:`, trpElement);
            console.log(`Affinity element:`, affinityElement);
            console.log(`Before discount element:`, beforeDiscountElement);
            console.log(`After discount element:`, afterDiscountElement);

            let spotCount = 0;
            let grpValue = 0;
            let trpValue = 0;
            let affinityValue = 0;
            let beforeDiscountValue = 0;
            let afterDiscountValue = 0;

            if (spotNumberElement) {
                spotCount = parseInt(spotNumberElement.textContent) || 0;
                console.log(`Found spot count: ${spotCount}`);
                totalSpots += spotCount;
            } else {
                console.log(`No spot-number element found in row ${index}`);
            }

            if (grpElement) {
                grpValue = parseFloat(grpElement.textContent) || 0;
                console.log(`Found GRP value: ${grpValue}`);
                // Just add the GRP value directly (not multiplied by spot count)
                console.log(`Adding GRP value to total: ${grpValue}`);
                totalGrp += grpValue;
            } else {
                console.log(`No GRP element found in row ${index}`);
            }

            if (trpElement) {
                trpValue = parseFloat(trpElement.textContent) || 0;
                console.log(`Found TRP value: ${trpValue}`);
                // Just add the TRP value directly (not multiplied by spot count)
                console.log(`Adding TRP value to total: ${trpValue}`);
                totalTrp += trpValue;
            } else {
                console.log(`No TRP element found in row ${index}`);
            }

            if (affinityElement) {
                affinityValue = parseFloat(affinityElement.textContent) || 0;
                console.log(`Found Affinity value: ${affinityValue}`);
                // Just add the Affinity value directly (not multiplied by spot count)
                console.log(`Adding Affinity value to total: ${affinityValue}`);
                totalAffinity += affinityValue;
            } else {
                console.log(`No Affinity element found in row ${index}`);
            }

            if (beforeDiscountElement) {
                beforeDiscountValue = parseFloat(beforeDiscountElement.textContent) || 0;
                console.log(`Found Before Discount value: ${beforeDiscountValue}`);
                // Just add the Before Discount value directly
                console.log(`Adding Before Discount value to total: ${beforeDiscountValue}`);
                totalBeforeDiscount += beforeDiscountValue;
            } else {
                console.log(`No Before Discount element found in row ${index}`);
            }

            if (afterDiscountElement) {
                afterDiscountValue = parseFloat(afterDiscountElement.textContent) || 0;
                console.log(`Found After Discount value: ${afterDiscountValue}`);
                // Just add the After Discount value directly
                console.log(`Adding After Discount value to total: ${afterDiscountValue}`);
                totalAfterDiscount += afterDiscountValue;
            } else {
                console.log(`No After Discount element found in row ${index}`);
            }
        });

        console.log(`Total spots calculated: ${totalSpots}`);
        console.log(`Total GRP calculated: ${totalGrp}`);
        console.log(`Total TRP calculated: ${totalTrp}`);
        console.log(`Total Affinity calculated: ${totalAffinity}`);
        console.log(`Total Before Discount calculated: ${totalBeforeDiscount}`);
        console.log(`Total After Discount calculated: ${totalAfterDiscount}`);

        // Update the station total spots element
        const totalSpotsElement = document.getElementById(`station-${stationId}-total-spots`);
        console.log(`Total spots element:`, totalSpotsElement);

        if (totalSpotsElement) {
            totalSpotsElement.textContent = totalSpots;
            console.log(`Updated station ${stationId} total spots to: ${totalSpots}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-spots`);
        }

        // Update the station total GRP element
        const totalGrpElement = document.getElementById(`station-${stationId}-total-grp`);
        console.log(`Total GRP element:`, totalGrpElement);

        if (totalGrpElement) {
            totalGrpElement.textContent = totalGrp.toFixed(2);
            console.log(`Updated station ${stationId} total GRP to: ${totalGrp.toFixed(2)}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-grp`);
        }

        // Update the station total TRP element
        const totalTrpElement = document.getElementById(`station-${stationId}-total-trp`);
        console.log(`Total TRP element:`, totalTrpElement);

        if (totalTrpElement) {
            totalTrpElement.textContent = totalTrp.toFixed(2);
            console.log(`Updated station ${stationId} total TRP to: ${totalTrp.toFixed(2)}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-trp`);
        }

        // Update the station total Affinity element
        const totalAffinityElement = document.getElementById(`station-${stationId}-total-affinity`);
        console.log(`Total Affinity element:`, totalAffinityElement);

        if (totalAffinityElement) {
            totalAffinityElement.textContent = totalAffinity.toFixed(2);
            console.log(`Updated station ${stationId} total Affinity to: ${totalAffinity.toFixed(2)}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-affinity`);
        }

        // Update the station total Before Discount element
        const totalBeforeDiscountElement = document.getElementById(`station-${stationId}-total-before-discount`);
        console.log(`Total Before Discount element:`, totalBeforeDiscountElement);

        if (totalBeforeDiscountElement) {
            totalBeforeDiscountElement.textContent = totalBeforeDiscount.toFixed(2);
            console.log(`Updated station ${stationId} total Before Discount to: ${totalBeforeDiscount.toFixed(2)}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-before-discount`);
        }

        // Update the station total After Discount element
        const totalAfterDiscountElement = document.getElementById(`station-${stationId}-total-after-discount`);
        console.log(`Total After Discount element:`, totalAfterDiscountElement);

        if (totalAfterDiscountElement) {
            totalAfterDiscountElement.textContent = totalAfterDiscount.toFixed(2);
            console.log(`Updated station ${stationId} total After Discount to: ${totalAfterDiscount.toFixed(2)}`);
        } else {
            console.log(`Could not find element with id: station-${stationId}-total-after-discount`);
        }
    }, 100);
}

function updateAllStationTotals() {
    // Get all unique station IDs from the page
    const stationIds = new Set();
    document.querySelectorAll('[data-station-id]').forEach(element => {
        const stationId = element.dataset.stationId;
        if (stationId) {
            stationIds.add(stationId);
        }
    });

    // Update totals for each station
    stationIds.forEach(stationId => {
        updateStationTotals(stationId);
    });
}

// Persistent spot loader that keeps trying until all spots are loaded
function startPersistentSpotLoader() {
    console.log('=== STARTING PERSISTENT SPOT LOADER ===');

    let retryCount = 0;
    const maxRetries = 10;
    const retryInterval = 1000; // 1 second

    function checkAndLoadSpots() {
        retryCount++;
        console.log(`=== PERSISTENT LOADER: Attempt ${retryCount}/${maxRetries} ===`);

        // Get API data and check if all spots are properly displayed
        fetch('/api/plans/{{ plan.id }}')
            .then(response => response.json())
            .then(data => {
                if (!data.spots || data.spots.length === 0) {
                    console.log('No spots in API data, stopping persistent loader');
                    return;
                }

                let missingSpots = 0;
                let totalSpots = data.spots.length;

                data.spots.forEach(spot => {
                    // Find the row for this spot
                    const spotDate = new Date(spot.date);
                    const dayOfWeek = spotDate.getDay();
                    const pythonWeekday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                    const isWeekend = pythonWeekday >= 5;

                    const rows = document.querySelectorAll(`tr[data-station-id="${spot.station_id}"][data-time-slot="${spot.time_slot}"][data-is-weekend="${isWeekend}"]`);

                    if (rows.length > 0) {
                        const row = rows[0];
                        const spotNumberElement = row.querySelector('.spot-number');

                        if (spotNumberElement) {
                            const currentValue = parseInt(spotNumberElement.textContent) || 0;

                            if (currentValue !== spot.spot_count) {
                                console.log(`Found missing spot: Station ${spot.station_id}, ${spot.time_slot}, expected ${spot.spot_count}, found ${currentValue}`);
                                // Update it immediately
                                spotNumberElement.textContent = spot.spot_count;

                                // Recalculate row prices
                                calculateRowPrices(row);
                                missingSpots++;
                            }
                        } else {
                            missingSpots++;
                        }
                    } else {
                        missingSpots++;
                    }
                });

                console.log(`Persistent loader: ${missingSpots}/${totalSpots} spots still missing or incorrect`);

                if (missingSpots === 0) {
                    console.log('=== PERSISTENT LOADER: All spots loaded successfully! ===');
                    updateAllStationTotals(); // Final totals update
                    return;
                }

                // If we still have missing spots and haven't exceeded max retries, try again
                if (retryCount < maxRetries) {
                    console.log(`Will retry in ${retryInterval}ms...`);
                    setTimeout(checkAndLoadSpots, retryInterval);
                } else {
                    console.log('=== PERSISTENT LOADER: Max retries reached, giving up ===');
                    updateAllStationTotals(); // Update totals with whatever we have
                }
            })
            .catch(error => {
                console.error('Persistent loader error:', error);
                if (retryCount < maxRetries) {
                    setTimeout(checkAndLoadSpots, retryInterval);
                }
            });
    }

    // Start the first check
    setTimeout(checkAndLoadSpots, 1000); // Wait 1 second before first check
}

// Test function to call manually
function testUpdateStationTotals() {
    console.log('=== MANUAL TEST: Calling updateStationTotals(1) ===');

    // First, let's see what station rows exist on the page
    console.log('=== DEBUGGING: Looking for all station rows ===');
    const allStationRows = document.querySelectorAll('[data-station-id]');
    console.log('Found rows with data-station-id:', allStationRows);

    allStationRows.forEach((row, index) => {
        console.log(`Row ${index}:`, row);
        console.log(`  - data-station-id: ${row.dataset.stationId}`);
        console.log(`  - classes: ${row.className}`);
    });

    // Now let's specifically look for station 1 rows
    console.log('=== DEBUGGING: Looking specifically for station 1 rows ===');
    const station1Rows = document.querySelectorAll('.station-1-row');
    console.log('Found station-1-row elements:', station1Rows);

    const station1DataRows = document.querySelectorAll('[data-station-id="1"]');
    console.log('Found data-station-id="1" elements:', station1DataRows);

    updateStationTotals(1);
}

function loadExistingSpots() {
    console.log('=== LOAD EXISTING SPOTS CALLED ===');
    console.log('Plan ID: {{ plan.id }}');

    // Load existing spots from the plan and populate saved ratings/prices
    fetch(`/api/plans/{{ plan.id }}`)
        .then(response => response.json())
        .then(data => {
            console.log('Loading existing spots:', data.spots);

            if (data.spots && data.spots.length > 0) {
                const stationIds = new Set();

                data.spots.forEach(spot => {
                    // Find the row that matches both station and time slot
                    const spotDate = new Date(spot.date);
                    const dayOfWeek = spotDate.getDay();
                    // JavaScript: Sunday = 0, Monday = 1, ..., Saturday = 6
                    // Python weekday(): Monday = 0, Tuesday = 1, ..., Sunday = 6
                    // Python uses >= 5 for weekend (Saturday=5, Sunday=6)
                    // So we need to match Python's logic: convert JS day to Python weekday
                    const pythonWeekday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Convert JS to Python weekday
                    const isWeekend = pythonWeekday >= 5; // Match Python's weekend calculation

                    console.log(`Spot date: ${spot.date}, Day of week: ${dayOfWeek}, Is weekend: ${isWeekend}`);
                    console.log(`Looking for row: station=${spot.station_id}, time=${spot.time_slot}, weekend=${isWeekend}`);

                    const selector = `tr[data-station-id="${spot.station_id}"][data-time-slot="${spot.time_slot}"][data-is-weekend="${isWeekend}"]`;
                    console.log(`Using selector: ${selector}`);

                    const row = document.querySelector(selector);

                    // Also check what rows exist for this station
                    const allStationRows = document.querySelectorAll(`tr[data-station-id="${spot.station_id}"]`);
                    console.log(`Found ${allStationRows.length} rows for station ${spot.station_id}`);
                    if (allStationRows.length > 0) {
                        console.log('First few rows:', Array.from(allStationRows).slice(0, 3).map(r => ({
                            timeSlot: r.getAttribute('data-time-slot'),
                            isWeekend: r.getAttribute('data-is-weekend')
                        })));
                    }

                    if (row) {
                        console.log(`Found row, updating spot count to ${spot.spot_count}`);

                        // Update the spot count display in the "Klipų skaičius" column
                        const spotNumberElement = row.querySelector('.spot-number');
                        if (spotNumberElement) {
                            spotNumberElement.textContent = spot.spot_count;
                            console.log(`Updated spot number display to ${spot.spot_count}`);
                        }
                    } else {
                        console.log(`Row not found with exact match. Trying without weekend filter...`);
                        // Try finding without the weekend filter as a fallback
                        const fallbackRow = document.querySelector(`tr[data-station-id="${spot.station_id}"][data-time-slot="${spot.time_slot}"]`);
                        if (fallbackRow) {
                            console.log(`Found row with fallback selector`);
                            const spotNumberElement = fallbackRow.querySelector('.spot-number');
                            if (spotNumberElement) {
                                // Get the current value and add to it (in case there are multiple spots)
                                const currentValue = parseInt(spotNumberElement.textContent) || 0;
                                spotNumberElement.textContent = currentValue + spot.spot_count;
                                console.log(`Updated spot number display to ${currentValue + spot.spot_count} (was ${currentValue})`);
                            }
                            row = fallbackRow; // Set row for calendar cell marking
                        } else {
                            console.log(`ERROR: Could not find row for station ${spot.station_id}, time slot ${spot.time_slot}`);
                        }
                    }

                    if (row) {
                        // Mark the calendar cell
                        const cell = row.querySelector(`td[data-date="${spot.date}"]`);
                        if (cell) {
                            const indicator = cell.querySelector('.spot-indicator');
                            indicator.textContent = spot.spot_count;
                            cell.classList.add('has-spot');
                        }

                        // Populate saved ratings and prices from the spot record
                        const grpCell = row.querySelector('.grp');
                        const trpCell = row.querySelector('.trp');
                        const affinityCell = row.querySelector('.affinity');
                        const basePriceCell = row.querySelector('.base-price');
                        const finalPriceCell = row.querySelector('.final-price');

                        if (grpCell && spot.grp) {
                            grpCell.textContent = (spot.grp / spot.spot_count).toFixed(2); // Base GRP per spot
                        }
                        if (trpCell && spot.trp) {
                            trpCell.textContent = (spot.trp / spot.spot_count).toFixed(2); // Base TRP per spot
                        }
                        if (affinityCell && spot.affinity) {
                            affinityCell.textContent = spot.affinity.toFixed(2);
                        }
                        if (basePriceCell && spot.base_price) {
                            basePriceCell.textContent = spot.base_price.toFixed(2);
                        }
                        if (finalPriceCell && spot.final_price) {
                            finalPriceCell.textContent = (spot.final_price / spot.spot_count).toFixed(2); // Price per spot
                        }

                        updateRowTotals(row);
                        stationIds.add(spot.station_id);

                        console.log(`Loaded saved data for station ${spot.station_id}, slot ${spot.time_slot}: GRP=${spot.grp}, TRP=${spot.trp}, Price=${spot.base_price}`);
                    }
                });

                // Update station totals for all stations that have spots
                stationIds.forEach(stationId => {
                    updateStationTotals(stationId);
                });
            }
        })
        .catch(error => console.error('Error loading spots:', error));
}

function applyDiscountsToAll() {
    // Get the discount values from inputs
    const ourDiscount = parseFloat(document.getElementById('globalOurDiscount').value) || 0;
    const clientDiscount = parseFloat(document.getElementById('globalClientDiscount').value) || 0;

    // Update all discount cells in the table
    const ourDiscountCells = document.querySelectorAll('.our-discount-percent');
    const clientDiscountCells = document.querySelectorAll('.client-discount-percent');

    ourDiscountCells.forEach(cell => {
        cell.textContent = ourDiscount + '%';
    });

    clientDiscountCells.forEach(cell => {
        cell.textContent = clientDiscount + '%';
    });

    // Recalculate all row prices with new discounts
    const allRows = document.querySelectorAll('.planning-row');
    allRows.forEach(row => {
        recalculateRowPricesWithDiscounts(row, ourDiscount, clientDiscount);
    });

    // Update station totals
    const stationIds = new Set();
    allRows.forEach(row => {
        const stationId = row.dataset.stationId;
        if (stationId) {
            stationIds.add(stationId);
        }
    });

    stationIds.forEach(stationId => {
        updateStationTotals(stationId);
    });

    // Show success message
    showNotification('Nuolaidos pritaikytos visoms eilutėms!', 'success');
}

function recalculateRowPricesWithDiscounts(row, ourDiscount, clientDiscount) {
    // Get values from the row
    const basePrice = parseFloat(row.querySelector('.base-price').textContent || 0);
    const seasonalIndex = parseFloat(row.querySelector('.seasonal-index').textContent || 1.0);
    const spotCount = parseInt(row.querySelector('.spot-number').textContent || 0);

    // Calculate price with seasonal index
    const priceWithIndex = basePrice * seasonalIndex;
    row.querySelector('.price-with-index').textContent = priceWithIndex.toFixed(2);

    // Calculate clip price (single spot price after seasonal adjustment)

    // Calculate total before discount (price * spot count)
    const totalBeforeDiscount = priceWithIndex * spotCount;
    row.querySelector('.total-before-discount').textContent = totalBeforeDiscount.toFixed(2);

    // Apply discounts
    const priceAfterOurDiscount = totalBeforeDiscount * (1 - ourDiscount / 100);
    const finalPrice = priceAfterOurDiscount * (1 - clientDiscount / 100);
    row.querySelector('.final-price').textContent = priceWithIndex.toFixed(2); // Single spot final price
    row.querySelector('.total-after-discount').textContent = finalPrice.toFixed(2);

    // Calculate TRP price if TRP is available using formula: įkainis / TRP
    const trp = parseFloat(row.querySelector('.trp').textContent || 0);
    console.log(`TRP calculation - basePrice: ${basePrice}, trp: ${trp}, station: ${row.getAttribute('data-station-id')}, time: ${row.getAttribute('data-time-slot')}`);
    if (trp > 0) {
        const trpPrice = basePrice / trp;
        console.log(`TRP price calculated: ${trpPrice.toFixed(2)}`);
        row.querySelector('.trp-price').textContent = trpPrice.toFixed(2);
    } else {
        console.log('TRP is 0 or missing, skipping TRP price calculation');
    }
}

function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `alert alert-${type} alert-dismissible fade show position-fixed top-0 end-0 m-3`;
    notification.style.zIndex = '9999';
    notification.innerHTML = `
        ${message}
        <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;

    document.body.appendChild(notification);

    // Auto-remove after 3 seconds
    setTimeout(() => {
        notification.remove();
    }, 3000);
}

// Initialize drag-to-scroll functionality for each station table
function initializeDragToScroll() {
    const stationWrappers = document.querySelectorAll('.station-table-wrapper');

    stationWrappers.forEach(wrapper => {
        let isDown = false;
        let startX;
        let scrollLeft;

        wrapper.addEventListener('mousedown', (e) => {
            // Only allow dragging in calendar date area (after the first 20 columns)
            const calendarDateHeaders = wrapper.querySelectorAll('.calendar-date-header');
            const isInCalendarArea = e.target.closest('.calendar-date-header') ||
                                   e.target.classList.contains('calendar-cell') ||
                                   e.target.closest('.calendar-cell');

            if (!isInCalendarArea) {
                return; // Don't allow dragging outside calendar area
            }

            // Allow normal click behavior for calendar cells with spot functionality
            if (e.target.tagName === 'TD' && e.target.classList.contains('calendar-cell')) {
                return;
            }

            isDown = true;
            wrapper.classList.add('active');
            startX = e.pageX - wrapper.offsetLeft;
            scrollLeft = wrapper.scrollLeft;
            e.preventDefault(); // Prevent text selection
        });

        wrapper.addEventListener('mouseleave', () => {
            isDown = false;
            wrapper.classList.remove('active');
        });

        wrapper.addEventListener('mouseup', () => {
            isDown = false;
            wrapper.classList.remove('active');
        });

        wrapper.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - wrapper.offsetLeft;
            const walk = (x - startX) * 2; // Adjust scroll speed multiplier
            wrapper.scrollLeft = scrollLeft - walk;
        });

        // Touch support for mobile devices
        wrapper.addEventListener('touchstart', (e) => {
            const isInCalendarArea = e.target.closest('.calendar-date-header') ||
                                   e.target.classList.contains('calendar-cell') ||
                                   e.target.closest('.calendar-cell');

            if (!isInCalendarArea) {
                return;
            }

            if (e.target.tagName === 'TD' && e.target.classList.contains('calendar-cell')) {
                return;
            }

            isDown = true;
            startX = e.touches[0].pageX - wrapper.offsetLeft;
            scrollLeft = wrapper.scrollLeft;
        });

        wrapper.addEventListener('touchend', () => {
            isDown = false;
        });

        wrapper.addEventListener('touchmove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.touches[0].pageX - wrapper.offsetLeft;
            const walk = (x - startX) * 2;
            wrapper.scrollLeft = scrollLeft - walk;
        });
    });
}

// Spot count control buttons
$(document).on('click', '.btn-spot-control', function() {
    const action = $(this).data('action');
    const row = $(this).closest('tr');
    const spotNumberElement = $(this).siblings('.spot-number');
    const currentCount = parseInt(spotNumberElement.text()) || 0;

    let newCount = currentCount;
    if (action === 'plus') {
        newCount = currentCount + 1;
    } else if (action === 'minus') {
        newCount = Math.max(0, currentCount - 1);
    }

    // Update the display immediately
    spotNumberElement.text(newCount);

    // Get row data - use attr() instead of data() to get exact attribute values
    const stationId = row.attr('data-station-id');
    const timeSlot = row.attr('data-time-slot');

    console.log('Row data extraction:', {
        stationId: stationId,
        timeSlot: timeSlot,
        stationIdType: typeof stationId,
        timeSlotType: typeof timeSlot,
        rowAttributes: {
            'data-station-id': row.attr('data-station-id'),
            'data-time-slot': row.attr('data-time-slot')
        }
    });

    // Check if this is a weekend row (VI-VII) or weekday row (I-V)
    const isWeekendRow = row.attr('data-is-weekend') === 'true';
    console.log('Is weekend row:', isWeekendRow);

    // Find a date with existing spots for this row, but only for the correct day type
    let selectedDate = null;
    const calendarCells = row.find('.calendar-cell');
    console.log('Found calendar cells:', calendarCells.length);

    row.find('.calendar-cell .spot-indicator').each(function() {
        if ($(this).text() && parseInt($(this).text()) > 0) {
            const cellDate = $(this).closest('.calendar-cell').attr('data-date');

            // Check if this date matches the row type (weekend vs weekday)
            const cellDateObj = new Date(cellDate);
            const dayOfWeek = cellDateObj.getDay();
            const isWeekendDate = (dayOfWeek === 0 || dayOfWeek === 6); // Sunday = 0, Saturday = 6

            console.log(`Checking date ${cellDate}: dayOfWeek=${dayOfWeek}, isWeekendDate=${isWeekendDate}, rowIsWeekend=${isWeekendRow}`);

            if (isWeekendDate === isWeekendRow) {
                selectedDate = cellDate;
                console.log('Found matching day type spot date:', selectedDate);
                return false; // break
            }
        }
    });

    // If no existing spots of the correct type, find the first calendar cell of the correct day type
    if (!selectedDate) {
        row.find('.calendar-cell').each(function() {
            const cellDate = $(this).attr('data-date');
            const cellDateObj = new Date(cellDate);
            const dayOfWeek = cellDateObj.getDay();
            const isWeekendDate = (dayOfWeek === 0 || dayOfWeek === 6);

            if (isWeekendDate === isWeekendRow) {
                selectedDate = cellDate;
                console.log('Using first matching day type calendar cell date:', selectedDate);
                return false; // break
            }
        });

        // Fallback: if still no date, use plan start date
        if (!selectedDate) {
            selectedDate = '{{ plan.start_date }}';
            console.log('Using plan start date as fallback:', selectedDate);
        }
    }

    console.log('Final data before API call:', {
        stationId: stationId,
        timeSlot: timeSlot,
        selectedDate: selectedDate,
        newCount: newCount
    });

    // 🚨 VERY CLEAR LOGGING FOR DEBUGGING 🚨
    const dateObj = new Date(selectedDate);
    const dayOfWeek = dateObj.getDay();
    const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek];
    const isActualWeekend = (dayOfWeek === 0 || dayOfWeek === 6);

    console.log(`🚨🚨🚨 SPOT BUTTON CLICKED 🚨🚨🚨`);
    console.log(`📍 ROW TYPE: ${isWeekendRow ? 'WEEKEND (VI-VII)' : 'WEEKDAY (I-V)'}`);
    console.log(`📅 SELECTED DATE: ${selectedDate} (${dayName})`);
    console.log(`🗓️ DATE IS ACTUALLY: ${isActualWeekend ? 'WEEKEND' : 'WEEKDAY'}`);
    console.log(`✅ MATCH: ${isWeekendRow === isActualWeekend ? 'CORRECT' : '❌ WRONG!'}`);
    console.log(`🚨🚨🚨 END SPOT DEBUG 🚨🚨🚨`);

    // Update spot count in database
    updateSpotCountInDatabase(stationId, timeSlot, selectedDate, newCount, row);
});

function updateSpotCountInDatabase(stationId, timeSlot, date, spotCount, row) {
    // Validate required fields before sending
    console.log('=== DEBUGGING API CALL DATA ===');
    console.log('stationId:', stationId, '(type:', typeof stationId, ')');
    console.log('timeSlot:', timeSlot, '(type:', typeof timeSlot, ')');
    console.log('date:', date, '(type:', typeof date, ')');
    console.log('spotCount:', spotCount, '(type:', typeof spotCount, ')');

    if (!stationId) {
        alert('Error: Station ID is missing');
        return;
    }
    if (!timeSlot) {
        alert('Error: Time slot is missing');
        return;
    }
    if (!date) {
        alert('Error: Date is missing');
        return;
    }

    console.log('Updating spot count:', {
        station_id: parseInt(stationId),
        time_slot: timeSlot,
        date: date,
        spot_count: parseInt(spotCount)
    });

    $.ajax({
        url: `/api/plans/{{ plan.id }}/spots/update-count`,
        method: 'PUT',
        contentType: 'application/json',
        data: JSON.stringify({
            station_id: parseInt(stationId),
            time_slot: timeSlot,
            date: date,
            spot_count: parseInt(spotCount)
        }),
        success: function(response) {
            console.log('Spot count updated successfully', response);
            // Update the row totals and calculations
            recalculateRowTotals(row);
        },
        error: function(xhr, status, error) {
            console.error('Error updating spot count:', error);
            console.error('XHR response:', xhr.responseText);
            let errorMessage = 'BAD REQUEST';
            try {
                const response = JSON.parse(xhr.responseText);
                errorMessage = response.error || error;
            } catch (e) {
                errorMessage = error + ' (Status: ' + xhr.status + ')';
            }
            alert('Error updating spot count: ' + errorMessage);
            // Revert the display
            const spotNumberElement = row.find('.spot-number');
            const originalCount = spotCount === 1 ? 0 : (spotCount === 0 ? 1 : spotCount);
            spotNumberElement.text(originalCount);
        }
    });
}

function recalculateRowTotals(row) {
    // Get spot count
    const spotCount = parseInt(row.find('.spot-number').text()) || 0;

    // Update total GRP and TRP
    const grp = parseFloat(row.find('.grp').text()) || 0;
    const trp = parseFloat(row.find('.trp').text()) || 0;


    // Update pricing calculations
    const basePrice = parseFloat(row.find('.base-price').text()) || 0;
    const finalPrice = parseFloat(row.find('.final-price').text()) || 0;

    row.find('.total-before-discount').text((basePrice * spotCount).toFixed(2));
    row.find('.total-after-discount').text((finalPrice * spotCount).toFixed(2));

    // Recalculate station totals
    updateAllStationTotals();
}

</script>

<style>
/* Professional Design System */
:root {
    --primary-color: #2563eb;
    --primary-hover: #1d4ed8;
    --secondary-color: #64748b;
    --success-color: #059669;
    --background-light: #f8fafc;
    --background-white: #ffffff;
    --text-primary: #1e293b;
    --text-secondary: #64748b;
    --text-muted: #94a3b8;
    --border-color: #e2e8f0;
    --border-light: #f1f5f9;
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    --radius-sm: 6px;
    --radius-md: 8px;
    --radius-lg: 12px;
}

/* Header Section */
.header-section {
    margin-bottom: 2rem;
}

.header-card {
    background: linear-gradient(135deg, #2d3748, #4a5568);
    color: white;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    padding: 2rem;
}

.header-top {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 2rem;
    padding-bottom: 1.5rem;
    border-bottom: 1px solid var(--border-light);
}

.campaign-title h1 {
    font-size: 1.875rem;
    font-weight: 700;
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
    line-height: 1.2;
}

.campaign-subtitle {
    color: var(--text-secondary);
    font-size: 0.875rem;
    font-weight: 500;
}

.header-actions {
    display: flex;
    gap: 0.75rem;
}

/* Info Grid */
.info-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 1.5rem;
}

.clips-section {
    border-top: 1px solid var(--border-light);
    padding-top: 1.5rem;
}

.info-item {
    background: rgba(255, 255, 255, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: var(--radius-md);
    padding: 1rem;
    transition: all 0.2s ease;
}

.info-item:hover {
    border-color: var(--primary-color);
    box-shadow: var(--shadow-sm);
}

.info-item.full-width {
    grid-column: 1 / -1;
}

.info-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.info-icon {
    color: rgba(255, 255, 255, 0.8);
    font-size: 1rem;
}

.info-label {
    color: #ffffff;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.info-value {
    color: #ffffff;
    font-size: 0.875rem;
    font-weight: 600;
    line-height: 1.4;
    background: rgba(255, 255, 255, 0.15);
    padding: 0.5rem 0.75rem;
    border-radius: 6px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    margin-top: 0.25rem;
    display: inline-block;
    min-width: 100px;
}

/* Professional Buttons */
.btn-professional {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    font-weight: 500;
    text-decoration: none;
    border: 1px solid transparent;
    transition: all 0.2s ease;
    cursor: pointer;
}

.btn-professional.btn-primary {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.btn-professional.btn-primary:hover {
    background: var(--primary-hover);
    border-color: var(--primary-hover);
    transform: translateY(-1px);
    box-shadow: var(--shadow-md);
}

.btn-professional.btn-secondary {
    background: var(--background-white);
    color: var(--text-secondary);
    border-color: var(--border-color);
}

.btn-professional.btn-secondary:hover {
    background: var(--background-light);
    color: var(--text-primary);
    border-color: var(--secondary-color);
}

.btn-professional.btn-full {
    width: 100%;
    justify-content: center;
}

/* Professional Sections */
.professional-section {
    background: var(--background-white);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-sm);
    margin-bottom: 2rem;
    overflow: hidden;
}

/* Station Sections - Individual spacing */
.station-section {
    margin-bottom: 3rem;
}

.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1.5rem 2rem;
    border-bottom: 1px solid var(--border-light);
    background: var(--background-light);
}

.section-title h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0 0 0.25rem 0;
}

.section-subtitle {
    color: var(--text-secondary);
    font-size: 0.875rem;
}

/* Controls Grid */
.controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    padding: 1.5rem 2rem;
}

.control-item {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.control-label {
    color: var(--text-primary);
    font-size: 0.875rem;
    font-weight: 500;
    margin-bottom: 0.25rem;
}

.input-group-professional {
    position: relative;
    display: flex;
}

.form-control-professional {
    flex: 1;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    color: var(--text-primary);
    background: var(--background-white);
    transition: all 0.2s ease;
}

.form-control-professional:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgb(37 99 235 / 0.1);
}

.input-suffix {
    padding: 0.5rem 0.75rem;
    background: var(--background-light);
    border: 1px solid var(--border-color);
    border-left: none;
    border-radius: 0 var(--radius-sm) var(--radius-sm) 0;
    color: var(--text-secondary);
    font-size: 0.875rem;
}

.help-text {
    color: var(--text-muted);
    font-size: 0.75rem;
    line-height: 1.4;
    margin-top: 0.5rem;
}

/* Table Container */
.table-container {
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
    overflow: hidden;
}

/* Professional Tables */
.professional-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.875rem;
    background: var(--background-white);
}

.professional-table th {
    background: var(--background-light);
    color: var(--text-primary);
    font-weight: 600;
    padding: 0.75rem;
    text-align: center;
    border-bottom: 2px solid var(--border-color);
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.professional-table .station-column {
    text-align: left;
    min-width: 150px;
    background: var(--background-white);
    font-weight: 600;
    color: var(--text-primary);
}

.professional-table td {
    padding: 0.5rem;
    border-bottom: 1px solid var(--border-light);
    text-align: center;
    vertical-align: middle;
}

.professional-table tbody tr:hover {
    background: var(--background-light);
}

/* Weekend styling */
.weekend-header {
    background: #fef2f2 !important;
    color: #991b1b;
}

.weekend-cell {
    background: #fef2f2;
}

.weekend-cell input {
    background: #fef2f2;
    border-color: #fecaca;
}

/* Calendar inputs */
.calendar-input-cell input {
    width: 60px;
    padding: 0.25rem;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    text-align: center;
    font-size: 0.75rem;
    background: var(--background-white);
}

.calendar-input-cell input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 2px rgb(37 99 235 / 0.1);
}

/* Planning Table Styling */
.planning-table-container {
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
    overflow: hidden;
    background: var(--background-white);
}

.planning-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.75rem;
    background: var(--background-white);
    min-width: 1800px; /* Ensure horizontal scrolling when needed */
}

/* Main Header Row */
.planning-table .main-header th {
    background: linear-gradient(135deg, #1e293b, #334155);
    color: white;
    padding: 1rem 0.5rem;
    text-align: center;
    font-weight: 600;
    font-size: 0.6rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    border-bottom: none;
    vertical-align: middle;
    position: relative;
}

/* Group Headers with Different Colors */
.rating-group-header {
    background: linear-gradient(135deg, #059669, #10b981) !important;
}

.pricing-group-header {
    background: linear-gradient(135deg, #dc2626, #ef4444) !important;
}

.totals-group-header {
    background: linear-gradient(135deg, #7c3aed, #8b5cf6) !important;
}

.discount-group-header {
    background: linear-gradient(135deg, #ea580c, #f97316) !important;
}

/* Sub Header Row */
.planning-table .sub-header th {
    background: var(--background-light);
    color: var(--text-primary);
    padding: 0.75rem 0.5rem;
    text-align: center;
    font-weight: 600;
    font-size: 0.65rem;
    border-bottom: 2px solid var(--border-color);
    vertical-align: middle;
}

/* Station and Basic Info Headers */
.station-header, .time-header, .weekday-header {
    background: linear-gradient(135deg, #475569, #64748b) !important;
    color: white;
    min-width: 100px;
}

.station-header {
    min-width: 120px;
    text-align: left !important;
}

/* Date Headers */
.calendar-date-header {
    background: var(--background-light) !important;
    min-width: 50px;
    padding: 0.5rem 0.25rem !important;
}

.calendar-date-header.weekend-date {
    background: linear-gradient(135deg, #fef2f2, #fee2e2) !important;
    color: #991b1b;
}

.date-info {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.125rem;
}

.date-day {
    font-weight: 700;
    font-size: 0.75rem;
}

.date-month {
    font-size: 0.6rem;
    opacity: 0.8;
}

/* Table Body Styling */
.planning-table tbody td {
    padding: 0.5rem 0.25rem;
    border-bottom: 1px solid var(--border-light);
    text-align: center;
    vertical-align: middle;
    font-size: 0.7rem;
    background: var(--background-white);
}

.planning-table tbody tr:hover {
    background: var(--background-light);
}

/* Station Separator Rows */
.station-separator td {
    height: 8px !important;
    padding: 0 !important;
    background: linear-gradient(90deg, var(--border-color), var(--border-light), var(--border-color)) !important;
    border: none !important;
}

/* Station Header Rows */
.station-header-row td {
    background: linear-gradient(135deg, #f1f5f9, #e2e8f0) !important;
    font-weight: 600 !important;
    color: var(--text-primary) !important;
    border-top: 2px solid var(--border-color) !important;
    border-bottom: 1px solid var(--border-color) !important;
    padding: 0.75rem 0.5rem !important;
}

/* Station Totals Rows */
.station-totals td {
    background: linear-gradient(135deg, #fff7ed, #ffedd5) !important;
    font-weight: 600 !important;
    border-top: 2px solid #fed7aa !important;
    border-bottom: 2px solid #fed7aa !important;
}

/* Weekend Rows */
.weekend-row td {
    background: #fefefe !important;
}

.weekend-row:hover td {
    background: #fef2f2 !important;
}

/* Calendar Cells */
.calendar-cell {
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    min-width: 50px;
}

.calendar-cell:hover {
    background: #e0f2fe !important;
    transform: scale(1.05);
}

.calendar-cell.has-spot {
    background: linear-gradient(135deg, #dcfce7, #bbf7d0) !important;
    border: 1px solid #22c55e !important;
}

.spot-indicator {
    font-weight: 700;
    color: #059669;
    font-size: 0.8rem;
}

/* Numeric Cells */
.grp, .trp, .affinity,
.trp-price, .base-price, .final-price, .total-before-discount, .total-after-discount {
    font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
    font-weight: 500;
    min-width: 70px;
}

/* Weekend Calendar Cells */
.weekend-cell {
    background: #fef2f2 !important;
}

.weekend-row .calendar-cell:not(.weekend-cell) {
    background: #f5f5f5 !important;
    opacity: 0.6;
    cursor: not-allowed;
}

/* Table responsive wrapper */
.table-responsive {
    overflow-x: auto;
    max-width: 100%;
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
}

/* Station Table Wrapper - Individual scrolling */
.station-table-wrapper {
    overflow-x: auto;
    max-width: 100%;
    border-radius: 0 0 var(--radius-lg) var(--radius-lg);
    scrollbar-width: thin;
    scrollbar-color: #cbd5e1 #f1f5f9;
}

/* Grab cursor only for calendar area where dragging is actually possible */
.calendar-date-header {
    cursor: grab;
}

.calendar-cell:not(.has-spot) {
    cursor: grab;
}

.calendar-cell.has-spot {
    cursor: pointer;
}

/* Grabbing cursor when actively dragging */
.station-table-wrapper:active .calendar-date-header,
.station-table-wrapper:active .calendar-cell:not(.has-spot) {
    cursor: grabbing;
}

/* Ensure other table cells have default cursor */
.planning-table td:not(.calendar-cell),
.planning-table th:not(.calendar-date-header) {
    cursor: default;
}

.station-table-wrapper::-webkit-scrollbar {
    height: 8px;
}

.station-table-wrapper::-webkit-scrollbar-track {
    background: #f1f5f9;
    border-radius: 4px;
}

.station-table-wrapper::-webkit-scrollbar-thumb {
    background: #cbd5e1;
    border-radius: 4px;
}

.station-table-wrapper::-webkit-scrollbar-thumb:hover {
    background: #94a3b8;
}

/* Calendar table styling */
#calendar-table {
    font-size: 13px;
}

#calendar-table th {
    vertical-align: middle;
    text-align: center;
    background-color: #f8f9fa;
    border-bottom: 2px solid #dee2e6;
    padding: 8px 4px;
}

.weekend-header {
    background-color: #f8d7da !important;
    color: #721c24;
}

.station-name-cell {
    background-color: #e9ecef;
    font-weight: bold;
    vertical-align: middle;
    padding: 8px 12px;
    min-width: 150px;
}

.calendar-input-cell {
    text-align: center;
    vertical-align: middle;
    padding: 4px !important;
    min-width: 80px;
}

.calendar-input-cell.weekend-cell {
    background-color: #fef2f2;
}

.calendar-input-cell input {
    border: 1px solid #ced4da;
    border-radius: 4px;
    padding: 2px 4px;
    text-align: center;
    width: 60px;
    margin: 0 auto;
}

.calendar-input-cell input:focus {
    border-color: #86b7fe;
    box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
}

.weekend-cell input {
    background-color: #fff5f5;
    border-color: #f8c2c5;
}

.table-responsive {
    overflow-x: auto;
    max-width: 100%;
}

.radio-planning-table {
    font-size: 11px;
}

.radio-planning-table th,
.radio-planning-table td {
    min-width: 50px;
    padding: 4px 6px;
    text-align: center;
    vertical-align: middle;
}

.calendar-cell {
    cursor: pointer;
    position: relative;
    width: 60px;
    height: 30px;
}

.calendar-cell:hover {
    background-color: #e9ecef;
}

.calendar-cell.has-spot {
    background-color: #d4edda;
}

.spot-indicator {
    font-weight: bold;
    color: #155724;
}

.calendar-date-header {
    writing-mode: vertical-rl;
    text-orientation: mixed;
    font-size: 10px;
    width: 60px;
}

.table-container {
    overflow-x: auto;
}

</style>
{% endblock %}

